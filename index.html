<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Longkx&#39;s notebook">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Longkx&#39;s notebook">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Long Kaixiang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>Longkx's notebook</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Longkx's notebook</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Long Kaixiang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/22/AWS%20SAP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Long Kaixiang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Longkx's notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/22/AWS%20SAP/" class="post-title-link" itemprop="url">aws sap笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-11-22 01:30:08 / 修改时间：01:30:36" itemprop="dateCreated datePublished" datetime="2020-11-22T01:30:08+08:00">2020-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/aws/" itemprop="url" rel="index"><span itemprop="name">aws</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="AWS-Rekognition"><a href="#AWS-Rekognition" class="headerlink" title="AWS Rekognition"></a>AWS Rekognition</h2><p>使用经过验证的、高度可扩展且无需机器学习专业知识就可使用的深度学习技术，Amazon Rekognition 可以轻松将图像和视频分析功能添加到您的应用程序中。借助 Amazon Rekognition，您可以在图像和视频中识别对象、人物、文本、场景和活动，也可以检测任何不适宜的内容。Amazon Rekognition 还提供高度精确的面孔分析和面孔搜索功能，您可以使用这些功能来检测、分析和对比面孔，以处理各种用户验证、人员计数和公共安全使用案例。</p>
<p>借助 Amazon Rekognition 自定义标签，您可以识别图像中特定于您的业务需求的对象和场景。例如，您可以构建模型来对装配线上的特定机器部件进行分类，或检测运行状况不佳的设备。Amazon Rekognition 自定义标签可以帮您完成繁重的模型开发工作，因此您无需具备机器学习经验。您只需提供想要识别的对象或场景的图像，剩下的工作都交由此项服务处理。</p>
<h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h2><h2 id="VPC"><a href="#VPC" class="headerlink" title="VPC"></a>VPC</h2><p>acl是拒绝的，安全组是设置允许的</p>
<h2 id="Kinesis"><a href="#Kinesis" class="headerlink" title="Kinesis"></a>Kinesis</h2><ul>
<li>Kinesis无法读取S3事件流</li>
</ul>
<p>Amazon Kinesis 可让您轻松收集、处理和分析实时流数据，以便您及时获得见解并对新信息快速做出响应。Amazon Kinesis 提供多种核心功能，可以经济高效地处理任意规模的流数据，同时具有很高的灵活性，让您可以选择最符合应用程序需求的工具。借助 Amazon Kinesis，您可以获取视频、音频、应用程序日志和网站点击流等实时数据，也可以获取用于机器学习、分析和其他应用程序的 IoT 遥测数据。借助 Amazon Kinesis，您可以即刻对收到的数据进行处理和分析并做出响应，无需等到收集完全部数据后才开始进行处理。</p>
<h2 id="Amazon-Simple-Queue-Service-SQS"><a href="#Amazon-Simple-Queue-Service-SQS" class="headerlink" title="Amazon Simple Queue Service (SQS)"></a>Amazon Simple Queue Service (SQS)</h2><p>Amazon Simple Queue Service (SQS) 是一种完全托管的消息队列服务，可让您分离和扩展微服务、分布式系统和无服务器应用程序。SQS 消除了与管理和运营消息型中间件相关的复杂性和开销，并使开发人员能够专注于重要工作。借助 SQS，您可以在软件组件之间发送、存储和接收任何规模的消息，而不会丢失消息，并且无需其他服务即可保持可用。使用 AWS 控制台、命令行界面或您选择的 SDK 和三个简单的命令，在几分钟内即可开始使用 SQS。</p>
<ul>
<li>SQS 提供两种消息队列类型。标准队列提供最高吞吐量、最大努力排序和至少一次传送。SQS FIFO 队列旨在确保按照消息的发送顺序对消息进行严格一次处理。</li>
<li>SQS无法直接发送数据到DynamoDB</li>
</ul>
<h2 id="Amazon-DynamoDB"><a href="#Amazon-DynamoDB" class="headerlink" title="Amazon DynamoDB"></a>Amazon DynamoDB</h2><p>Amazon DynamoDB 是一个键/值和文档数据库，可以在任何规模的环境中提供个位数的毫秒级性能。它是一个<strong>完全托管、多区域多主的持久数据库</strong>，具有适用于 Internet 规模的应用程序的内置安全性、备份和恢复和内存缓存。DynamoDB 每天可处理超过 10 万亿个请求，并可支持每秒超过 2000 万个请求的峰值。</p>
<ul>
<li>对于需要以微秒级延迟执行更快访问的使用案例，DynamoDB Accelerator (DAX) 提供了完全托管的内存缓存。</li>
<li>DynamoDB 可自动纵向扩展和缩减表，以针对容量做出调整并保持性能。</li>
<li>DynamoDB 支持 ACID 事务，使您能够大规模构建业务关键型应用程序。DynamoDB 默认加密所有数据，并为您的所有表提供细粒度的身份和访问控制。</li>
</ul>
<h2 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h2><p>通过 AWS Lambda，无需预置或管理服务器即可运行代码。您只需按使用的计算时间付费。</p>
<ul>
<li>lambda只是执行代码的，不支持搜索，不支持创建索引</li>
<li>实时数据流处理:您可以使用 AWS Lambda 和 Amazon Kinesis 处理实时流数据，从而跟踪应用程序活动、处理事务处理顺序、分析单击数据流、整理数据、生成指标、筛选日志、建立索引、分析社交媒体以及遥测和计量 IoT 设备数据。</li>
<li>数据处理:您可以使用 AWS Lambda 执行代码以响应数据更改、系统状态变化或用户操作等触发器。Lambda 可以由 S3、DynamoDB、Kinesis、SNS 和 CloudWatch 等 AWS 服务直接触发，可以连接到现有的 EFS 文件系统，也可以通过 AWS Step Functions 编排到工作流程中。您可借此构建各种实时的无服务器数据处理系统。</li>
<li>实时文件处理:您可以使用 Amazon S3 触发 AWS Lambda，以便在上传数据后立即对它们进行处理。您还可以直接连接到现有的 Amazon EFS 文件系统，从而支持对大规模文件处理进行大规模并行共享访问。例如，您可以使用 Lambda 实时创建缩略图、转换视频代码、建立文件索引、处理日志、验证内容以及聚合和筛选数据。</li>
<li>lambda不支持增加cpu，是通过增加内存增加对应的cpu</li>
<li>lambda并发1000上限</li>
</ul>
<h2 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h2><p>将函数组装到业务关键型应用程序中<br>WS Step Functions 是一个无服务器函数编排工具，可轻松将 AWS Lambda 函数和多个 AWS 服务按顺序安排到业务关键型应用程序中。通过其可视界面，您可以创建并运行一系列检查点和事件驱动的工作流，以维护应用程序状态。 每一步的输出作为下一步的输入。应用程序中的各个步骤根据业务逻辑定义的顺序执行。</p>
<p>编排一系列无服务器应用程序、管理重试和调试故障可能颇具挑战性。随着分布式应用程序变得越来越复杂，管理它们的复杂性也随之增加。Step Functions 可自动管理错误处理、重试逻辑和状态。 凭借内置的操作控制功能，Step Functions 可以管理执行任务的顺序、错误处理、重试逻辑和状态，从而显著减轻团队的运营负担。</p>
<h2 id="Amazon-Cognito"><a href="#Amazon-Cognito" class="headerlink" title="Amazon Cognito"></a>Amazon Cognito</h2><p>简单安全的用户注册、登录和访问控制<br>借助 Amazon Cognito，您可以快速轻松地为 Web 和移动应用程序添加用户注册/登录和访问控制功能。Amazon Cognito 可将用户规模扩展到数百万，并支持通过 SAML 2.0 使用社交身份提供商 (如 Facebook、Google 和 Amazon) 以及企业身份提供商进行登录。</p>
<ul>
<li>SAML:全断言标记语言（英语：Security Assertion Markup Language，简称SAML，发音sam-el）是一个基于XML的开源标准数据格式，它在当事方之间交换身份验证和授权数据，尤其是在身份提供者和服务提供者之间交换。</li>
</ul>
<h2 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h2><p>AWS Elastic Beanstalk 是一项易于使用的服务，用于在熟悉的服务器（例如 Apache 、Nginx、Passenger 和 IIS ）上部署和扩展使用 Java、.NET、PHP、Node.js、Python、Ruby、GO 和 Docker 开发的 Web 应用程序和服务。</p>
<p>您只需上传代码，Elastic Beanstalk 即可自动处理包括<strong>容量预配置、负载均衡、自动扩展和应用程序运行状况监控</strong>在内的部署工作。同时，您能够完全控制为应用程序提供支持的 AWS 资源，并可以随时访问底层资源。</p>
<p>Elastic Beanstalk 不额外收费 – 您只需为存储和运行应用程序所需的 AWS 资源付费。</p>
<h2 id="Amazon-AppStream-2-0"><a href="#Amazon-AppStream-2-0" class="headerlink" title="Amazon AppStream 2.0"></a>Amazon AppStream 2.0</h2><p>Amazon AppStream 2.0 是一种完全托管的非永久性应用程序和桌面流式传输服务。您可以在 AppStream 2.0 上集中管理桌面应用程序，并将它们安全地交付到任何计算机上。您可以轻松扩展到全球任意数量的用户，而无需获取、预置和操作硬件或基础设施。AppStream 2.0 基于 AWS 构建，因此您可以从专为对安全最敏感的组织设计的数据中心和网络架构中受益。 每个最终用户都可以获得流畅的响应式体验，因为您的应用程序在针对特定使用案例优化的虚拟机上运行，并且每个流式传输会话都会根据网络条件自动调整。</p>
<ul>
<li>将桌面应用程序交付给任何计算机</li>
<li>AppStream 2.0 通过在云中安全运行桌面应用程序并向您的用户提供每个应用程序的同一版本，简化了应用程序交付</li>
</ul>
<h2 id="AWS-Key-Management-Service-KMS"><a href="#AWS-Key-Management-Service-KMS" class="headerlink" title="AWS Key Management Service (KMS)"></a>AWS Key Management Service (KMS)</h2><p>AWS Key Management Service (KMS) 可让您轻松创建和管理加密密钥，并控制其在各种 AWS 服务和应用程序中的使用。AWS KMS 是一种安全且有弹性的服务，它使用已经过 FIPS 140-2 验证或正在验证的硬件安全模块来保护您的密钥。AWS KMS 还能与 AWS CloudTrail 集成，从而为您提供所有密钥的使用记录，帮助您满足监管和合规性要求。</p>
<ul>
<li>您可以从 AWS 管理控制台或使用 AWS SDK 或 CLI 轻松创建、导入、轮换、删除和管理密钥权限。</li>
<li>AWS KMS 与 AWS 服务集成，可简化密钥使用以加密 AWS 工作负载中的数据。</li>
<li>KMS 会将密钥的所有使用记录到 AWS CloudTrail，以便为您提供访问加密数据的用户的独立视图，包括代表您使用这些数据的 AWS 服务。AWS KMS 与 AWS CloudTrail 集成，可记录所有 API 请求，包括密钥管理操作和密钥使用情况。</li>
</ul>
<h2 id="AWS-CloudHSM"><a href="#AWS-CloudHSM" class="headerlink" title="AWS CloudHSM"></a>AWS CloudHSM</h2><p>AWS CloudHSM 是基于云的硬件安全模块 (HSM)，让您能够在 AWS 云上轻松生成和使用自己的加密密钥。借助 CloudHSM，您可以使用经过 FIPS 140-2 第 3 级验证的 HSM 管理自己的加密密钥。CloudHSM 让您可以灵活选择使用行业标准的 API 与应用程序集成，这些 API 包括 PKCS#11、Java 加密扩展 (JCE) 和 Microsoft CryptoNG (CNG) 库等。</p>
<ul>
<li>HSM 可满足的安全级别更高，支持的协议更多，还支持非对称加密， KMS只支持对称加密</li>
<li>KMS 是多租户的密钥管理服务    HSM是单租户的密钥管理服务（租的是独立物理加密机）</li>
</ul>
<h2 id="Amazon-CloudWatch"><a href="#Amazon-CloudWatch" class="headerlink" title="Amazon CloudWatch"></a>Amazon CloudWatch</h2><p>利用 Amazon CloudWatch 警报操作，您可创建自动停止、终止、重启或恢复实例的警报。<br>Amazon CloudWatch 是一种面向开发运营工程师、开发人员、站点可靠性工程师 (SRE) 和 IT 经理的监控和可观测性服务。CloudWatch 为您提供相关数据和切实见解，以监控应用程序、响应系统范围的性能变化、优化资源利用率，并在统一视图中查看运营状况。CloudWatch 以日志、指标和事件的形式收集监控和运营数据，让您能够在统一查看在 AWS 和本地服务器上运行的资源、应用程序和服务。您可以使用 CloudWatch 检测环境中的异常行为、设置警报、并排显示日志和指标、执行自动化操作、排查问题，以及发现可确保应用程序正常运行的见解。</p>
<ul>
<li>将其与 AWS X-Ray 的跟踪数据相结合，以实现端到端的可观测性。</li>
<li>CloudWatch 警报会根据您指定的阈值或 CloudWatch 使用机器学习模型为您创建的阈值来监控您的指标值，从而检测异常行为。如果触发警报，CloudWatch 可以自动采取措施启用 Amazon EC2 Auto Scaling 或停止实例，以便您自动执行容量和资源规划。</li>
<li>了解、分析并可视化日志，以解决运营问题并提高应用程序性能。</li>
</ul>
<h2 id="Amazon-Route-53"><a href="#Amazon-Route-53" class="headerlink" title="Amazon Route 53"></a>Amazon Route 53</h2><p>Amazon Route 53 是一种可用性高、可扩展性强的云域名系统 (DNS) Web 服务。Amazon Route 53 也与 IPv6 完全兼容。Amazon Route 53 高效地将用户请求连接到 AWS 中运行的基础设施，例如 Amazon EC2 实例、Elastic Load Balancing 负载均衡器或 Amazon S3 存储桶，还可以将用户路由到 AWS 外部的基础设施。您可以使用 Amazon Route 53 配置 DNS 运行状况检查以将流量路由到正常的终端节点，或者独立监控应用程序及其终端节点的运行状况。Amazon Route 53 Traffic Flow 让您可以通过多种路由类型（包括基于延迟的路由、Geo DNS、临近地理位置路由和加权轮询）轻松管理全球流量，所有的路由类型都可与 DNS 故障转移进行组合，以实现各种低延迟容错架构。利用 Amazon Route 53 Traffic Flow 简单的可视化编辑器，您可以轻松管理如何将终端用户路由到应用程序的终端节点，无论是在单个 AWS 区域还是在分布于全球的区域都可实现。Amazon Route 53 还提供域名注册功能，您可以购买和管理域名（例如 example.com），且 Amazon Route 53 将自动为您的域配置 DNS 设置。</p>
<h2 id="Elastic-Load-Balancing-ELB"><a href="#Elastic-Load-Balancing-ELB" class="headerlink" title="Elastic Load Balancing(ELB)"></a>Elastic Load Balancing(ELB)</h2><p>Elastic Load Balancing 在多个目标（如 Amazon EC2 实例、容器、IP 地址和 Lambda 函数）之间自动分配传入的应用程序流量。它可以在单个可用区内处理不断变化的应用程序流量负载，也可以跨多个可用区处理此类负载。Elastic Load Balancing 提供三种负载均衡器，它们均能实现高可用性、自动扩展和可靠的安全性，因此能让您的应用程序获得容错能力。</p>
<ul>
<li>Application Load Balancer(ALB)Application Load Balancer 最适合 HTTP 和 HTTPS 流量的负载均衡，面向交付包括微服务和容器在内的现代应用程序架构，提供高级请求路由功能。Application Load Balancer 运行于单独的请求级别（第 7 层），可根据请求的内容将流量路由至 Amazon Virtual Private Cloud (Amazon VPC) 内的不同目标。</li>
<li>网络负载均衡器(NLB):若要对需要极高性能的传输控制协议 (TCP)、用户数据报协议 (UDP) 和传输层安全性 (TLS) 协议流量进行负载均衡，最适合使用网络负载均衡器。</li>
<li>Classic Load Balancer:Classic Load Balancer 同时运行于请求级别和连接级别，可在多个 Amazon EC2 实例之间提供基本的负载均衡。</li>
<li></li>
<li>提高应用程序的容错能力</li>
<li>自动扩展应用程序  Auto Scaling</li>
<li>混合负载均衡和 Elastic Load Balancing</li>
<li>通过 HTTP(S) 调用 Lambda 函数</li>
</ul>
<h2 id="Amazon-ElastiCache"><a href="#Amazon-ElastiCache" class="headerlink" title="Amazon ElastiCache"></a>Amazon ElastiCache</h2><p>与 Redis 或 Memcached 兼容的完全托管型内存中数据存储。支持实时应用程序，提供亚毫秒级延迟。<br>Amazon ElastiCache 支持横向扩展、缩减及纵向扩展，可满足不断变化的应用需求。可通过分区实现写入扩展和内存扩展。Replicas 提供读取扩展功能。</p>
<h2 id="AWS-Schema-Conversion-Tool-AWS-SCT"><a href="#AWS-Schema-Conversion-Tool-AWS-SCT" class="headerlink" title="AWS Schema Conversion Tool (AWS SCT)"></a>AWS Schema Conversion Tool (AWS SCT)</h2><p>使用 AWS Schema Conversion Tool (AWS SCT) 将 Oracle 架构转换为 Aurora MySQL 架构</p>
<h2 id="AWS-Application-Discovery-Service"><a href="#AWS-Application-Discovery-Service" class="headerlink" title="AWS Application Discovery Service"></a>AWS Application Discovery Service</h2><p>AWS Application Discovery Service 可以收集有关企业客户的本地数据中心的信息，从而帮助企业客户规划迁移项目。</p>
<p>数据中心迁移的规划工作可能会涉及数千个通常高度相互依赖的工作负载。确定服务器利用率数据和依赖关系映射是迁移流程中的一个重要前期步骤。AWS Application Discovery Service 可以收集和提供服务器的配置、使用和行为数据，帮助您更好地了解您的工作负载。</p>
<p>收集的数据以加密格式保留在 AWS Application Discovery Service 的数据存储中。您可以将该数据导出为 CSV 文件，利用其来估算在 AWS 上运行的总体拥有成本 (TCO) 并规划向 AWS 的迁移工作。此外，该数据还保留在 AWS Migration Hub 中，您可以在其中迁移发现的服务器并跟踪其迁移到 AWS 的进度。</p>
<h2 id="AWS-Server-Migration-Service-SMS"><a href="#AWS-Server-Migration-Service-SMS" class="headerlink" title="AWS Server Migration Service (SMS)"></a>AWS Server Migration Service (SMS)</h2><p>是一种无代理服务，可以让您更加轻松快速地将成千上万的本地工作负载迁移到 AWS。借助 AWS SMS，您可以自动执行实时服务器卷的增量复制、对其制定计划以及进行跟踪，从而能够更轻松地协调大规模服务器迁移。</p>
<h2 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h2><p>AWS CloudFormation 通过将基础设施视为代码，为您提供一种简单的方式，为一系列相关 AWS 资源和第三方资源建模，快速而又一致地对这些资源进行预置并在它们的整个生命周期内对其进行管理。CloudFormation 模板描述了您所需的资源及其依赖项，这样，您就可以将它们一起作为一个堆栈进行启动和配置。</p>
<ul>
<li>AWS CloudFormation 现在支持上调对五个服务配额的限制</li>
</ul>
<h2 id="AWS-Auto-Scaling"><a href="#AWS-Auto-Scaling" class="headerlink" title="AWS Auto Scaling"></a>AWS Auto Scaling</h2><p>AWS Auto Scaling 可以监控您的应用程序并自动调整容量，从而以尽可能低的成本来保持稳定、可预测的性能。使用 AWS Auto Scaling，您可以在几分钟内为多项服务中的多个资源轻松设置应用程序扩展。该服务可以提供一个简单而功能强大的用户界面，让您可以为 Amazon EC2 实例和 Spot 队列、Amazon ECS 任务、Amazon DynamoDB 表和索引以及 Amazon Aurora 副本等资源制定扩展计划。AWS Auto Scaling 可以提供建议，让您能够优化性能、成本或实现二者的平衡，从而使扩展变得简单。如果您已经在使用 Amazon EC2 Auto Scaling 来动态扩展 Amazon EC2 实例，那么现在可以将其与 AWS Auto Scaling 结合使用，为其他 AWS 服务扩展其他资源。有了 AWS Auto Scaling，您的应用程序就始终能在合适的时间获得合适的资源。</p>
<h2 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h2><p>AWS Batch 让开发人员、科学家和工程师能够轻松高效地在 AWS 上运行成千上万个批处理计算作业。AWS Batch 可根据提交的批处理作业的卷和特定资源需求动态预置最佳的计算资源（如 CPU 或内存优化实例）数量和类型。借助 AWS Batch，您无需安装和管理运行您的作业所使用的批处理计算软件或服务器集群，从而使您能够专注于分析结果和解决问题。AWS Batch 将通过全系列的 AWS 计算服务和功能（如 Amazon EC2 和 Spot 实例）计划、安排和执行批量计算工作负载。</p>
<p>AWS Batch 无需额外付费。您只需为存储和运行您的批处理作业而创建的 AWS 资源（如 EC2 实例）付费。</p>
<h2 id="AWS-X-Ray"><a href="#AWS-X-Ray" class="headerlink" title="AWS X-Ray"></a>AWS X-Ray</h2><p>AWS X-Ray 可以帮助开发人员分析与调试分布式生产应用程序，例如使用微服务架构构建的应用程序。借助 X-Ray，您可以了解应用程序及其底层服务的执行方式，从而识别和排查导致性能问题和错误的根本原因。X-Ray 可在请求通过应用程序时提供请求的端到端视图，并展示应用程序底层组件的映射。您可以使用 X-Ray 分析开发和生产中的应用程序，从简单的三层应用程序到包含上千种服务的复杂微服务应用程序。</p>
<h2 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h2><p>AWS Glue 是完全托管的提取、转换和加载 (ETL) 服务，有了它，您可以轻松地准备并加载数据以进行分析。您只需在 AWS Glue 可视化编辑器中单击几次，即可创建并运行 ETL 作业。您只需将 AWS Glue 指向存储在 AWS 上的数据或兼容 JDBC 的源，AWS Glue 便会发现您的数据，并将关联的元数据（例如表定义和架构）存储到 AWS Glue 数据目录中。存入目录后，您的数据可立即供 ETL 搜索、查询和使用。</p>
<h2 id="Amazon-EMR"><a href="#Amazon-EMR" class="headerlink" title="Amazon EMR"></a>Amazon EMR</h2><p>Amazon EMR 是行业领先的云大数据平台，可使用多种开放源代码工具处理大量数据，例如 Apache Spark、Apache Hive、Apache HBase、Apache Flink、Apache Hudi 和 Presto。借助 EMR，您可以用不到传统本地解决方案一半的成本运行 PB 级分析，并且其速度比标准 Apache Spark 快 3 倍以上。对于短期运行的作业，您可以启动和关闭集群，并对使用的实例按秒支付费用。对于长期运行的工作负载，您可以创建能自动扩展的高度可用的集群以满足需求。如果您拥有 Apache Spark 和 Apache Hive 等开源工具的现有本地部署，您还可以在 AWS Outposts 上运行 EMR 集群。</p>
<h2 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h2><p>AWS Fargate 是一种适用于容器的无服务器计算引擎，可与 Amazon Elastic Container Service (ECS) 和 Amazon Elastic Kubernetes Service (EKS) 一起使用。Fargate 使您可以轻松专注于构建应用程序。使用 Fargate，您无需预置和管理服务器，而且可以为每个应用程序指定资源并为其付费，并通过设计隔离应用程序来提高安全性。</p>
<h2 id="Spot-Fleet-API"><a href="#Spot-Fleet-API" class="headerlink" title="Spot Fleet API"></a>Spot Fleet API</h2><p>简单来说，通过这个API，用户不再需要关注每个竞价实例的具体竞价策略，转向关注自己业务需要的计算量、完成时间以及成本，而具体竞价实例的组合搭配则由AWS在后台根据当前竞价实例价格智能帮助用户选择。</p>
<h2 id="AWS-CodeBuild"><a href="#AWS-CodeBuild" class="headerlink" title="AWS CodeBuild"></a>AWS CodeBuild</h2><p>AWS CodeBuild 是一项完全托管的持续集成服务，可编译源代码、运行测试以及生成可供部署的软件包。使用 CodeBuild，您无需预置、管理和扩展自己的构建服务器。CodeBuild 可以持续扩展并同时处理多项构建任务，因此您的构建任务不会在队列中等待。您可以使用预先打包的构建环境快速开始，也可以创建使用您自己的构建工具的自定义构建环境。使用 CodeBuild，将按使用计算资源的分钟数向您收取费用。</p>
<ul>
<li>AWS CodeBuild 属于 AWS Code 服务系列，您可以使用该服务创建完整、自动的软件发布工作流程，以实现持续集成和持续交付 (CI/CD)。</li>
<li>借助 AWS CodeBuild，您的构建项目可使用由 AWS Key Management Service (KMS) 托管的客户专用密钥加密。CodeBuild 与 AWS Identity and Access Management (IAM) 集成，因此您可以为特定用户分配构建项目权限。</li>
<li><h2 id="AWS-CodeDeploy"><a href="#AWS-CodeDeploy" class="headerlink" title="AWS CodeDeploy"></a>AWS CodeDeploy</h2>AWS CodeDeploy 是一项将软件自动部署到各种计算服务（例如 Amazon EC2、AWS Fargate、AWS Lambda 和本地服务器）的完全托管的部署服务。借助 AWS CodeDeploy，您可以更轻松地快速发布新功能，避免在应用程序部署过程中出现停机，并简化应用程序的更新工作。您可以使用 AWS CodeDeploy 自动执行软件部署，而无需执行容易出错的手动操作。服务根据您的部署需求进行扩展。</li>
</ul>
<h2 id="AWS-CodePipeline"><a href="#AWS-CodePipeline" class="headerlink" title="AWS CodePipeline"></a>AWS CodePipeline</h2><p>AWS CodePipeline 是一种完全托管的持续集成与持续交付服务，可以帮助您实现发布管道的自动化，从而实现快速而可靠的应用程序和基础设施更新。代码一旦发生更改，CodePipeline 都会根据您定义的发布模型自动构建、测试和部署您的发布流程。这使您能够快速而可靠地提供各种功能和更新。您可以将 AWS CodePipeline 与 GitHub 等第三方服务或您自己的自定义插件轻松集成。</p>
<h2 id="Amazon-Athena"><a href="#Amazon-Athena" class="headerlink" title="Amazon Athena"></a>Amazon Athena</h2><p>Amazon Athena 是一种交互式查询服务，让您能够轻松使用标准 SQL 分析 Amazon S3 中的数据。Athena 没有服务器，因此您无需管理任何基础设施，且只需为您运行的查询付费。</p>
<p>Athena 可与 AWS Glue 数据目录进行开箱即用集成，让您能够跨各种服务创建统一的元数据存储库、抓取数据源以发现架构并使用新的和修改后的表与分区定义填充数据目录，以及维护架构版本控制。</p>
<h2 id="VPC终端节点-VPC-Endpoint"><a href="#VPC终端节点-VPC-Endpoint" class="headerlink" title="VPC终端节点(VPC Endpoint)"></a>VPC终端节点(VPC Endpoint)</h2><p>VPC 终端节点 使您能够将 VPC 私密地连接到支持的 AWS 服务和 VPC 终端节点服务（由 AWS PrivateLink 提供支持），而无需互联网网关、NAT 设备、VPN 连接或 AWS Direct Connect 连接。VPC 中的实例无需公有 IP 地址便可与服务中的资源通信。VPC 和其他服务之间的通信不会离开 Amazon 网络。</p>
<p>终端节点是虚拟设备。它们是水平扩展、冗余和高度可用的 VPC 组件。通过它们，可以在 VPC 中的实例与服务之间进行通信，而不会对网络通信带来可用性风险或带宽约束。<br>VPC 终端节点有两种类型：接口终端节点 和 网关终端节点。创建受支持的服务所需要的 VPC 终端节点 类型。</p>
<p>接口终端节点是一个弹性网络接口，具有来自子网 IP 地址范围的私有 IP 地址，用作发送到受支持的服务的通信的入口点。接口终端节点由 AWS PrivateLink 提供支持，您可以使用该技术通过私有 IP 地址私密访问服务。AWS PrivateLink 限制您的 VPC 和服务之间的所有网络流量到达 Amazon 网络。您无需互联网网关、NAT 设备或虚拟私有网关。</p>
<h2 id="AWS-Systems-Manager"><a href="#AWS-Systems-Manager" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h2><p>AWS Systems Manager 让您能够查看和控制 AWS 上的基础设施。Systems Manager 可以提供一个统一的用户界面，供您查看多种 AWS 服务的运行数据，并在 AWS 资源上自动执行操作任务。借助 Systems Manager，您可以按应用程序对 Amazon EC2 实例、Amazon S3 存储桶或 Amazon RDS 实例等资源进行分组、查看运行数据以便进行监控和故障排除，并对各组资源采取行动。Systems Manager 可以简化资源和应用程序管理、缩短检测和解决运行问题的时间，并让您轻松安全地大规模运行和管理基础设施。</p>
<h2 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h2><p>AWS Global Accelerator 是通过 Amazon Web Service 的全球网络基础设施发送您的用户流量的联网服务，将您的互联网用户性能提升了高达 60%。当互联网拥塞时，Global Accelerator 的自动路由优化会帮助您将数据包丢失、抖动和延迟水平持续维持在低水平。</p>
<p>凭借 Global Accelerator，您可获得两个面向客户的全球静态 IP，以简化流量管理。在后端，增加或删除您的 AWS 应用程序源，如 Network Load Balancers、Application Load Balancers、弹性 IP 和 EC2 实例，无需作出面向用户的更改。为减少终端节点故障，Global Accelerator 自动将您的流量重新路由至您最近的正常运行的可用终端节点。</p>
<h2 id="Amazon-Macie"><a href="#Amazon-Macie" class="headerlink" title="Amazon Macie"></a>Amazon Macie</h2><p>Amazon Macie 是一项完全托管的数据安全和数据隐私服务，它利用机器学习和模式匹配来发现和保护 AWS 中的敏感数据。<br>Amazon Macie 使用机器学习和模式匹配来经济高效地大规模发现敏感数据。Macie 会自动检测大量不断增多的敏感数据类型，包括姓名、地址和信用卡号等个人身份信息 (PII)。</p>
<h2 id="AWS-Organizations"><a href="#AWS-Organizations" class="headerlink" title="AWS Organizations"></a>AWS Organizations</h2><p>AWS Organizations 可帮助您在增长和扩展 AWS 资源时集中管理和治理您的环境。使用 AWS Organizations，您可以以编程方式创建新的 AWS 账户和分配资源、将账户分组以组织您的工作流程、应用策略到账户或组中进行治理，并通过为所有账户使用一种付款方式来简化计费。</p>
<p>另外，AWS Organizations 与其他 AWS 服务进行了集成，以便在您的组织中跨账户指定中央配置、安全机制、审计要求和资源共享。所有 AWS 客户都可以使用 AWS Organizations，且无需额外付费。</p>
<p>通过将账户组织到组织单位 (OU)（提供应用程序或服务的账户组）中，您可以应用服务控制策略 (SCP) 以为您的 OU 创建目标治理边界。</p>
<p>使用 AWS Single Sign-On (SSO) 和活动目录为组织中的所有人进行简单的基于用户的权限管理。通过为作业类别创建自定义权限来应用最小特权实践。您还可以通过向用户、账户或 OU 应用服务控制策略 (SCP) 来控制对 AWS 服务的访问权。</p>
<h2 id="SCP"><a href="#SCP" class="headerlink" title="SCP"></a>SCP</h2><p>默认情况下，用户没有任何类型的权限。所有权限都必须通过策略明确授予。如果未明确授予某个权限，则默示拒绝该权限。如果明确拒绝了某个权限，则其优于任何其他可能允许该权限的策略。换而言之，用户仅具有明确授予和未明确拒绝的权限。</p>
<h2 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h2><p>您可以指定允许规则，但不可指定拒绝规则。<br>当您创建一个安全组时，它没有入站规则。因此，在您向安全组添加入站规则之前，不允许来自另一台主机的入站流量传输到您的实例。</p>
<h2 id="网络-ACL"><a href="#网络-ACL" class="headerlink" title="网络 ACL"></a>网络 ACL</h2><p>您的 VPC 中的每个子网都必须与一个网络 ACL 相关联。如果您没有明确地将子网与网络 ACL 相关联，则子网将自动与默认网络 ACL 关联。默认情况下，每个自定义网络 ACL 都拒绝所有入站和出站流量，直至您添加规则。</p>
<p>您可以将网络 ACL 与多个子网关联。但是，一个子网一次只能与一个网络 ACL 关联。当您将一个网络 ACL 与一个子网关联时，将删除之前的关联。</p>
<h2 id="AWS-Service-Catalog"><a href="#AWS-Service-Catalog" class="headerlink" title="AWS Service Catalog"></a>AWS Service Catalog</h2><p>利用 AWS Service Catalog，组织可以创建和管理已批准在 AWS 上使用的 IT 服务的目录。这些 IT 服务可谓包罗万象，从虚拟机映像、服务器、软件和数据库，再到完整的多层应用程序架构。AWS Service Catalog 使您可以集中管理普遍部署的 IT 服务，帮助您实现一致性管理并满足您的合规性要求，同时使用户能够仅快速部署所需的已批准 IT 服务。</p>
<h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><p>Kibana 是一种开源数据可视化和挖掘工具，可以用于日志和时间序列分析、应用程序监控和运营智能使用案例。它提供了强大且易用的功能，例如直方图、线形图、饼图、热图和内置的地理空间支持。此外，它还提供了与 Elasticsearch 的紧密集成，后者是一款流行的分析和搜索引擎，这使得 Kibana 成为了可视化 Elasticsearch 中存储数据的默认之选。</p>
<h2 id="Amazon-Inspector"><a href="#Amazon-Inspector" class="headerlink" title="Amazon Inspector"></a>Amazon Inspector</h2><p>Amazon Inspector 是一项自动安全评估服务，有助于提高在 AWS 上部署的应用程序的安全性与合规性。Amazon Inspector 会自动评估应用程序的风险、漏洞或者相较于最佳实践的偏差。执行评估后，Amazon Inspector 会生成按严重程度确定优先级的安全检测详细列表。这些评估结果可直接接受审核，也可作为通过 Amazon Inspector 控制台或 API 提供的详细评估报告的一部分接受审核。</p>
<p>Amazon Inspector 安全评估可帮助您检查 Amazon EC2 实例是否存在意外的网络可访问性和漏洞。Amazon Inspector 评估以预定义规则包（映射到常见安全最佳实践和漏洞定义）的形式提供给您。内置规则的示例包括检查从 Internet 对您的 EC2 实例进行的访问、当前启用的远程根登录，或已安装的易受攻击的软件版本。AWS 安全研究员会定期更新这些规则。</p>
<h2 id="Amazon-GuardDuty"><a href="#Amazon-GuardDuty" class="headerlink" title="Amazon GuardDuty"></a>Amazon GuardDuty</h2><p>提供智能威胁检测和持续监控，保护您的 AWS 账户、工作负载和数据<br>Amazon GuardDuty 是一种威胁检测服务，可持续监控恶意活动和未经授权的行为，从而保护您的 AWS 账户、工作负载和在 Amazon S3 中存储的数据。迁移到云后，账户和网络活动的收集与聚合变得异常简单，但安全团队对事件日志数据进行持续的分析以发现潜在的威胁，则可能十分耗时。GuardDuty 为您提供了经济高效的智能选项，从而持续检测在 AWS 中发生的威胁。此服务使用机器学习、异常检测和集成威胁情报等手段，识别潜在的威胁并确定优先级别。GuardDuty 对来自多个 AWS 数据源（例如 AWS CloudTrail 事件日志、Amazon VPC 流日志和 DNS 日志）的数百亿事件进行分析。只需在 AWS 管理控制台中几次点击，就可以启用 GuardDuty，无需部署或维护任何软件或硬件。GuardDuty 警报与 Amazon CloudWatch Events 集成，具有极好的可行动性，非常便于跨多个账户聚合，并且可以直接推送到现有的事件管理和工作流程系统。</p>
<h2 id="Amazon-EventBridge"><a href="#Amazon-EventBridge" class="headerlink" title="Amazon EventBridge"></a>Amazon EventBridge</h2><p>EventBridge 架构注册表会将事件架构存储在注册表中，以方便组织中的其他开发人员搜索和访问，而无需手动查找事件及其结构。该注册表还允许您在 IDE 中直接生成 Java、Python 或 Typescript 等编程语言的代码绑定，从而在代码中以对象形式使用这些事件。启用事件总线的 Schema 发现功能之后，系统将会自动发现 Schema 事件并将其添加至注册表中，而无需手动创建事件 Schema。所有 AWS 服务 Schema 会自动显示在您的 Schema 注册表中，而当您启用 SaaS 合作伙伴事件总线的 Schema 发现功能后，将会看到集成 SaaS 应用程序的 Schema。<br>完全托管且可扩展的事件总线<br>Amazon EventBridge 与超过 90 个事件源以及超过 15 个目标直接集成，其中包括 AWS Lambda、Amazon SQS、Amazon SNS、AWS Step Functions、Amazon Kinesis Data Streams、Amazon Kinesis Data Firehose 等等，此外还有其他已在计划中的来源和目标。所有 AWS 服务中的所有更改类 API 调用（即，除 Describe<em>、List</em> 和 Get* 之外的所有调用）都通过 AWS CloudTrail 生成事件。</p>
<h2 id="AWS-IoT-Greengrass"><a href="#AWS-IoT-Greengrass" class="headerlink" title="AWS IoT Greengrass"></a>AWS IoT Greengrass</h2><p>将本地计算、消息收发、数据管理、同步和 ML 推理功能引入边缘设备</p>
<h2 id="Amazon-Simple-Notification-Service"><a href="#Amazon-Simple-Notification-Service" class="headerlink" title="Amazon Simple Notification Service"></a>Amazon Simple Notification Service</h2><p>完全托管的发布/订阅消息收发、SMS、电子邮件和移动推送通知<br>借助 Amazon SNS 主题，发布系统可以向大量订阅系统（包括 Amazon SQS 队列、AWS Lambda 函数和 HTTP/S 终端节点）扇出消息，从而实现并行处理。使用 A2P 功能，您可以通过 SMS、移动推送和电子邮件将消息大规模发送给用户。</p>
<h2 id="Amazon-Redshift"><a href="#Amazon-Redshift" class="headerlink" title="Amazon Redshift"></a>Amazon Redshift</h2><p>任何其他数据仓库都无法像它这样轻松地从所有数据中获得新见解。借助 Redshift，您可以使用标准 SQL 在数据仓库、运营数据库和数据湖中查询 PB 级结构化和半结构化数据。Redshift 使您能够使用开放格式（如 Apache Parquet）轻松地将查询结果保存回 S3 数据湖，以便在其他分析服务（如 Amazon EMR、Amazon Athena 和 Amazon SageMaker）中进一步分析。</p>
<h2 id="AWS-AppSync"><a href="#AWS-AppSync" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h2><p>借助可扩展的 GraphQL API 加快应用程序开发速度</p>
<p>组织选择使用 GraphQL 构建 API 的原因是，GraphQL 可以通过使得前端开发人员能够查询多个数据库、微服务和具有单个 GraphQL 终端节点的 API 来帮助他们更快地开发应用程序。</p>
<p>AWS AppSync 是一项完全托管的服务，通过处理与 AWS DynamoDB、Lambda 等数据源之间繁重的安全连接任务来简化 GraphQL API 的开发。添加缓存以提高性能、订阅以支持实时更新以及客户端数据存储以使离线客户端保持同步等操作也一样轻松简单。部署之后，AWS AppSync 会自动向上扩展和缩减 GraphQL API 执行引擎以满足 API 请求量。</p>
<h2 id="OAI-源访问身份"><a href="#OAI-源访问身份" class="headerlink" title="OAI 源访问身份"></a>OAI 源访问身份</h2><h2 id="AWS-Certificate-Manager"><a href="#AWS-Certificate-Manager" class="headerlink" title="AWS Certificate Manager"></a>AWS Certificate Manager</h2><p>轻松预置、管理和部署公有和私有 SSL/TLS 证书，以便用于 AWS 服务和您的内部互联资源</p>
<p>利用 AWS Certificate Manager，您可以快速请求证书，在与 ACM 集成的 AWS 资源（例如 Elastic Load Balancer、Amazon CloudFront 分配和 API Gateway 上的 API）上部署该证书，并让 AWS Certificate Manager 处理证书续订事宜。它还让您能够为内部资源创建私有证书并集中管理证书生命周期。通过 AWS Certificate Manager 预置的用于 ACM 集成服务的公有和私有证书均免费。您只需为您创建的用于运行应用程序的 AWS 资源付费。</p>
<h2 id="AWS-Directory-Service"><a href="#AWS-Directory-Service" class="headerlink" title="AWS Directory Service"></a>AWS Directory Service</h2><p>适用于 Microsoft Active Directory 的 AWS Directory Service 又称为 AWS Managed Microsoft Active Directory (AD)，可以支持目录感知型工作负载和各种 AWS 资源，以在 AWS 中使用托管的 Active Directory (AD)。AWS Managed Microsoft AD 基于实际的 Microsoft AD 构建，不需要您将数据从现有 Active Directory 同步或复制到云中。您可以使用标准的 AD 管理工具，还可利用各种内置的 AD 功能，例如组策略和单点登录。借助 AWS Managed Microsoft AD，您可以将 Amazon EC2 和 Amazon RDS for SQL Server 实例轻松加入到域中，并使用 Amazon WorkSpaces 等 AWS 最终用户计算 (EUC) 服务以及 AD 用户和组。</p>
<h2 id="AWS-WAF-–-Web-应用程序防火墙"><a href="#AWS-WAF-–-Web-应用程序防火墙" class="headerlink" title="AWS WAF – Web 应用程序防火墙"></a>AWS WAF – Web 应用程序防火墙</h2><p>AWS WAF 是一种 Web 应用程序防火墙，可帮助保护您的 Web 应用程序或 API 免遭常见 Web 漏洞的攻击，这些漏洞可能会影响可用性、损害安全性或消耗过多的资源。AWS WAF 允许您创建防范常见攻击模式（例如 SQL 注入或跨站点脚本）的安全规则，以及滤除您定义的特定流量模式的规则，从而让您可以控制流量到达您的应用程序的方式。您可以通过适用于 AWS WAF 的托管规则快速入门，这是由 AWS 或 AWS Marketplace 卖家托管的一套预配置规则。适用于 WAF 的托管规则可以解决 OWASP 十大安全风险等问题。这些规则会随新问题的出现定期更新。AWS WAF 包含功能全面的 API，借此您可以让安全规则的创建、部署和维护实现自动化。</p>
<p>使用 AWS WAF，您只需按使用量付费。定价基于您部署的规则数量和您的应用程序收到的 Web 请求数量。无需预先承诺。</p>
<p>您可以将 AWS WAF 作为 CDN 解决方案的一部分部署到 Amazon CloudFront 上，也可以将其部署到位于 Web 服务器或来源服务器（运行于 EC2 上）之前的 Application Load Balancer 上，或者是适用于您的 API 的 Amazon API Gateway 上。</p>
<h2 id="Amazon-API-Gateway"><a href="#Amazon-API-Gateway" class="headerlink" title="Amazon API Gateway"></a>Amazon API Gateway</h2><p>创建、维护和保护任意规模的 API</p>
<h2 id="AWS-Batch-1"><a href="#AWS-Batch-1" class="headerlink" title="AWS Batch"></a>AWS Batch</h2><p>AWS Batch 让开发人员、科学家和工程师能够轻松高效地在 AWS 上运行成千上万个批处理计算作业。AWS Batch 可根据提交的批处理作业的卷和特定资源需求动态预置最佳的计算资源（如 CPU 或内存优化实例）数量和类型。借助 AWS Batch，您无需安装和管理运行您的作业所使用的批处理计算软件或服务器集群，从而使您能够专注于分析结果和解决问题。AWS Batch 将通过全系列的 AWS 计算服务和功能（如 Amazon EC2 和 Spot 实例）计划、安排和执行批量计算工作负载。</p>
<h2 id="AWS-Cost-Explorer"><a href="#AWS-Cost-Explorer" class="headerlink" title="AWS Cost Explorer"></a>AWS Cost Explorer</h2><p>界面易于使用，可让您直观看到、理解和管理随时间变化的 AWS 成本和使用情况。</p>
<p>通过创建分析成本和使用情况数据的自定义报告，快速入门。高水平分析数据（例如，所有账户的总成本和使用情况），或者更深入地研究成本和使用情况数据，从而发现趋势，查明成本动因素并检测异常情况。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/22/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Long Kaixiang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Longkx's notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/22/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">aws sap笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-22 01:30:08" itemprop="dateCreated datePublished" datetime="2020-11-22T01:30:08+08:00">2020-11-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-10 01:43:15" itemprop="dateModified" datetime="2021-02-10T01:43:15+08:00">2021-02-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/aws/" itemprop="url" rel="index"><span itemprop="name">aws</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[toc]</p>
<h1 id="云原生起源"><a href="#云原生起源" class="headerlink" title="云原生起源"></a>云原生起源</h1><p><strong>云原生（Cloud Native）</strong>的概念，由来自Pivotal的MattStine于2013年首次提出，被一直延续使用至今。这个概念是Matt Stine根据其多年的架构和咨询经验总结出来的一个思想集合，并得到了社区的不断完善，内容非常多，<strong>包括DevOps、持续交付（Continuous Delivery）、微服务（MicroServices）、敏捷基础设施（Agile Infrastructure）和12要素（TheTwelve-Factor App）等几大主题，</strong>不但包括根据业务能力对公司进行文化、组织架构的重组与建设，也包括方法论与原则，还有具体的操作工具。采<strong>用基于云原生的技术和管理方法，可以更好地把业务生于“云”或迁移到云平台，从而享受“云”的高效和持续的服务能力。</strong>顾名思义，云原生是面向“云”而设计的应用，因此技术部分依赖于在传统云计算的3层概念（基础设施即服务（IaaS）、平台即服务（PaaS）和软件即服务（SaaS）），例如，敏捷的不可变基础设施交付类似于IaaS，用来提供计算网络存储等基础资源，这些资源是可编程且不可变的，直接通过API可以对外提供服务；有些应用通过PaaS服务本来就能组合成不同的业务能力，不一定需要从头开始建设；还有一些软件只需要“云”的资源就能直接运行起来为云用户提供服务，即SaaS能力，用户直接面对的就是原生的应用。应用基于云服务进行架构设计，对技术人员的要求更高，除了对业务场景的考虑外，对隔离故障、容错、自动恢复等非功能需求会考虑更多。借助云服务提供的能力也能实现更优雅的设计，比如弹性资源的需求、跨机房的高可用、11个9（99.999999999%）的数据可靠性等特性，基本是云计算服务本身就提供的能力，开发者直接选择对应的服务即可，一般不需要过多考虑本身机房的问题。如果架构设计本身又能支持多云的设计，可用性会进一步提高，比如Netflix能处理在AWS的某个机房无法正常工作的情况，还能为用户提供服务，这就是“云”带来的魔力，当然，云也会带来更多的隔离等问题。如图1-4所示，目前业界公认的云原生主要包括以下几个层面的内容。<img src="https://mmbiz.qpic.cn/mmbiz_jpg/MF3QcUFhrlymZEcezKdnNTwsmz6PmrJMpogiceTibfSgH4cCqBkOBGwNSzXKKukBKT0icBypVJh2EUBSic8sF2a89Q/640?wx_fmt=jpeg" alt="img"></p>
<h1 id="敏捷基础设施"><a href="#敏捷基础设施" class="headerlink" title="敏捷基础设施"></a>敏捷基础设施</h1><p>正如通过业务代码能够实现产品需求、通过版本化的管理能够保证业务的快速变更，基于云计算的开发模式也要考虑如何保证基础资源的提供能够根据代码自动实现需求，并实现记录变更，保证环境的一致性。使用软件工程中的原则、实践和工具来提供基础资源的生命周期管理，这意味着工作人员可以更频繁地构建更强可控或更稳定的基础设施，开发人员可以随时拉取一套基础设施来服务于开发、测试、联调和灰度上线等需求。当然，同时要求业务开发具有较好的架构设计，不需要依赖本地数据进行持久化，所有的资源都是可以随时拉起，随时释放，同时以API的方式提供弹性、按需的计算、存储能力。</p>
<p>技术人员部署服务器、管理服务器模板、更新服务器和定义基础设施的模式都是通过代码来完成的，并且是自动化的，不能通过手工安装或克隆的方式来管理服务器资源，运维人员和开发人员一起以资源配置的应用代码为中心，不再是一台台机器。基础设施通过代码来进行更改、测试，在每次变更后执行测试的自动化流程中，确保能维护稳定的基础设施服务。此外，基础设施的范围也会更加广泛，不仅包括机器，还包括不同的机柜或交换机、同城多机房、异地多机房等，这些内容也会在后续章节中逐一进行部分讨论。</p>
<h1 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h1><p>为了满足业务需求频繁变动，通过快速迭代，产品能做到随时都能发布的能力，是一系列的开发实践方法。它分为持续集成、持续部署、持续发布等阶段，用来确保从需求的提出到设计开发和测试，再到让代码快速、安全地部署到产品环境中。</p>
<p>持续集成是指每当开发人员提交了一次改动，就立刻进行构建、自动化测试，确保业务应用和服务能符合预期，从而可以确定新代码和原有代码能否正确地集成在一起。持续交付是软件发布的能力，在持续集成完成之后，能够提供到预发布之类系统上，达到生产环境的条件，持续部署是指使用完全的自动化过程来把每个变更自动提交到测试环境中，然后将应用安全地部署到产品环境中，打通开发、测试、生产的各个环节，自动持续、增量地交付产品，也是大量产品追求的最终目的，当然，在实际运行的过程中，有些产品会增加灰度发布等环境。总之，它更多是代表一种软件交付的能力，过程示例请参考下图。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MF3QcUFhrlymZEcezKdnNTwsmz6PmrJMZUq4xZJSjOByqw7tjkItX6wich9ZQnk0nXn9nvsCFGAq0ttudazkdTg/640?wx_fmt=jpeg" alt="img"></p>
<h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><p>DevOps如果从字面上来理解只是Dev（开发人员）+Ops（运维人员），实际上，它是一组过程、方法与系统的统称，其概念从2009年首次提出发展到现在，内容也非常丰富，有理论也有实践，包括组织文化、自动化、精益、反馈和分享等不同方面。</p>
<p>首先，组织架构、企业文化与理念等，需要自上而下设计，用于促进开发部门、运维部门和质量保障部门之间的沟通、协作与整合，简单而言组织形式类似于系统分层设计。其次，自动化是指所有的操作都不需要人工参与，全部依赖系统自动完成，比如上述的持续交付过程必须自动化才有可能完成快速迭代。再次，DevOps的出现是由于软件行业日益清晰地认识到，为了按时交付软件产品和服务，开发部门和运维部门必须紧密合作。总之，如图所示，DevOps强调的是高效组织团队之间如何通过自动化的工具协作和沟通来完成软件的生命周期管理，从而更快、更频繁地交付更稳定的软件。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MF3QcUFhrlymZEcezKdnNTwsmz6PmrJMkUgf9zOLiaE4g3pENC96ibscJZvrU1kAG3kicdksIic6xIIavChluz2jJg/640?wx_fmt=jpeg" alt="img"></p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><p>随着企业的业务发展，传统业务架构面临着很多问题。</p>
<p>其一，单体架构在需求越来越多的时候无法满足其变更要求，开发人员对大量代码的变更会越来越困难，同时也无法很好地评估风险，所以迭代速度慢；</p>
<p>其二，系统经常会因为某处业务的瓶颈导致整个业务瘫痪，架构无法扩展，木桶效应严重，无法满足业务的可用性要求；</p>
<p>最后，整体组织效率低下，无法很好地利用资源，存在大量的浪费。因此，组织迫切需要进行变革。随着大量开源技术的成熟和云计算的发展，服务化的改造应运而生，不同的架构设计风格随之涌现，最有代表性的是Netflix公司，它是国外最早基于云进行服务化架构改造的公司，2008年因为全站瘫痪被迫停业3天后，它痛下决心改造，经过将近10年的努力，实现了从单架构到微服务全球化的变迁，满足了业务的千倍增长（如图），并产生了一系列的最佳实践。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MF3QcUFhrlymZEcezKdnNTwsmz6PmrJMoticRXbQmVB0QZiaDuehul8o03RZMN3vIdZ8s4RoKY2reDXr6ebExuLg/640?wx_fmt=jpeg" alt="img"></p>
<p>随着微服务化架构的优势展现和快速发展，2013年，MartinFlower对微服务概念进行了比较系统的理论阐述，总结了相关的技术特征。首先，微服务是一种架构风格，也是一种服务；其次，微服务的颗粒比较小，一个大型复杂软件应用由多个微服务组成，比如Netflix目前由500多个的微服务组成；最后，它采用UNIX设计的哲学，每种服务只做一件事，是一种松耦合的能够被独立开发和部署的无状态化服务（独立扩展、升级和可替换）。微服务架构如图所示。<img src="https://mmbiz.qpic.cn/mmbiz_jpg/MF3QcUFhrlymZEcezKdnNTwsmz6PmrJMxUeQFUUYricTaic2gywNqDr3ZAmbyEj5tEkLpicnQibO7CJCIibicVibICbuA/640?wx_fmt=jpeg" alt="img"></p>
<p>由微服务的定义分析可知，一个微服务基本是一个能独立发布的应用服务，因此可以作为独立组件升级、灰度或复用等，对整个大应用的影响也较小，每个服务可以由专门的组织来单独完成，依赖方只要定好输入和输出口即可完全开发，甚至整个团队的组织架构也会更精简，因此沟通成本低、效率高。根据业务的需求，不同的服务可以根据业务特性进行不同的技术选型，是计算密集型还是I/O密集型应用都可以依赖不同的语言编程模型，各团队可以根据本身的特色独自运作。服务在压力较大时，也可以有更多容错或限流服务。微服务架构确实有很多吸引人的地方，然而它的引入也是有成本的，它并不是银弹，使用它会引入更多技术挑战，比如性能延迟、分布式事务、集成测试、故障诊断等方面，企业需要根据业务的不同的阶段进行合理的引入，不能完全为了微服务而“微服务”，本书第5章也会对如何解决这些问题提供对应不同方案的权衡。</p>
<h1 id="12要素"><a href="#12要素" class="headerlink" title="12要素"></a>12要素</h1><p>“12要素”英文全称是The Twelve-Factor App，最初由Heroku的工程师整理起步，是集体贡献总结的智慧，如图1-9所示。根据基于云的软件开发模式，12要素比较贴切地描述了软件应用的原型，并诠释了使用原生云应用架构的原因。</p>
<p>比如，一个优雅的互联网应用在设计过程中，需要遵循的一些基本原则和云原生有异曲同工之处。通过强化详细配置和规范，类似Rails的基于“约定优于配置”（convention over configuration）的原则，特别在大规模的软件生产实践中，这些约定非常重要，从无状态共享到水平扩展的过程，从松耦合架构关系到部署环境。基于12要素的上下文关联，软件生产就变成了一个个单一的部署单元；多个联合部署的单元组成一个应用，多个应用之间的关系就可以组成一个复杂的分布式系统应用。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MF3QcUFhrlymZEcezKdnNTwsmz6PmrJMZ9sfPkhZrKx3KjrObibbLBXR5S4lJpiaKNtsmM9hXHg8K3OnHBhHWCcQ/640?wx_fmt=jpeg" alt="img"></p>
<p>下面简要介绍图中的这些原则。相信很多开发者在实际开发工作中已经很好地应用了其中的一些原则，只是没有意识到概念本身。对这些原则比较陌生的开发者，如果想了解更多的操作过程，请参阅《云原生时代下的12要素（12-Factor）应用与实践》一文。</p>
<ol>
<li><strong>基准代码</strong>每一个部署的应用都在版本控制代码库中被追踪。在多个部署环境中，会有多种部署实例，单个应用只有一份代码库，多份部署相当于运行了该应用的多个实例，比如开发环境一个实例，测试环境、生产环境都有一个实例。实际上，在云计算架构中，所有的基础设施都是代码配置，即Infrastructure as Code（IaC），整个应用通过配置文件就可以编排出来，而不再需要手工的干预，做到基础服务也是可以追踪的。</li>
<li><strong>依赖</strong>应用程序不会隐式依赖系统级的类库，通过依赖清单声明所有依赖项，通过依赖隔离工具确保程序不会调用系统中存在，但清单中未声明依赖项，并统一应用到生产和开发环境。比如通过合适的工具（例如Maven、Bundler、NPM），应用可以很清晰地对部署环境公开和隔绝依赖性，而不是模糊地对部署环境产生依赖性。在容器应用中，所有应用的依赖和安装都是通过Dockerfile来完成声明的，通过配置能明确把依赖关系，包括版本都明确地图形化展示出来，不存在黑盒。</li>
<li><strong>配置</strong>环境变量是一种清楚、容易理解和标准化的配置方法，将应用的配置存储于环境变量中，保证配置排除在代码之外，或者其他可能在部署环境（例如研发、展示、生产）之间区别的任何代码，可以通过操作系统级的环境变量来注入。实例根据不同的环境配置运行在不同的环境中，此外，实现配置即代码，在云环境中，无论是统一的配置中心还是分布式的配置中心都有好的实践方式，比如Docker的环境变量使用。</li>
<li><strong>后端服务</strong>不用区别对待本地或第三方服务，统一把依赖的后端作为一种服务来对待，例如数据库或者消息代理，作为附加资源，同等地在各种环境中被消耗。比如在云架构的基础服务中，计算、网络、存储资源都可以看作是一种服务去对待使用即可，不用区分是远程还是本地的。</li>
<li><strong>构建、发布、运行</strong>应用严格区分构建、发布、运行这3个阶段。3个阶段是严格分开的，一个阶段对应做一件事情，每个阶段有很明确的实现功能。云原生应用的构建流程可以把发布配置挪到开发阶段，包括实际的代码构建和运行应用所需的生产环境配置。在云原生应用中，基于容器的Build-Ship-Run和这3个阶段完全吻合，也是Docker对本原则的最佳实践。</li>
<li><strong>进程</strong>进程必须无状态且无共享，即云应用以一个或多个无状态不共享的程序运行。任何必要状态都被服务化到后端服务中（缓存、对象存储等）。所有的应用在设计时就认为随时随地会失败，面向失败而设计，因此进程可能会被随时拉起或消失，特别是在弹性扩容的阶段。</li>
<li><strong>端口绑定</strong>不依赖于任何网络服务器就可以创建一个面向网络的服务，每个应用的功能都很齐全，通过端口绑定对外提供所有服务，比如Web应用通过端口绑定（Port binding）来提供服务，并监听发送至该端口的请求（包括HTTP）。在容器应用中，应用统一通过暴露端口来服务，尽量避免通过本地文件或进程来通信，每种服务通过服务发现而服务。</li>
<li><strong>并发</strong>进程可以看作一等公民，并发性即可以依靠水平扩展应用程序来实现，通过进程模型进行扩展，并且具备无共享、水平分区的特性。在互联网的服务中，业务的爆发性随时可能发生，因此不太可能通过硬件扩容来随时提供扩容服务，需要依赖横向扩展能力进行扩容。</li>
<li><strong>易处理</strong>所有应用的架构设计都需要支持能随时销毁的特点，和状态的无关性保持一致，允许系统快速弹性扩展、改变部署及故障恢复等。在云环境中，由于业务的高低峰值经常需要能实现快速灵活、弹性的伸缩应用，以及不可控的硬件因素等，应用可能随时会发生故障，因此应用在架构设计上需要尽可能无状态，应用能随时随地拉起，也能随时随地销毁，同时保证进程最小启动时间和架构的可弃性，也可以提供更敏捷的发布及扩展过程。</li>
<li><strong>环境等价</strong>必须缩小本地与线上差异，确保环境的一致性，保持研发、测试和生产环境尽可能相似，这样可以提供应用的持续交付和部署服务。在容器化应用中，通过文件构建的环境运行能做到版本化，因此保证各个不同环境的差异性，同时还能大大减少环境不同带来的排错等成本沟通问题。</li>
<li><strong>日志</strong>每一个运行的进程都会直接标准输出（stdout）和错误输出（stderr）事件流，还可以将日志当作事件流作为数据源，通过集中服务，执行环境收集、聚合、索引和分析这些事件。日志是系统运行状态的部分体现，无论在系统诊断、业务跟踪还是后续大数据服务的必要条件中，Docker提供标准的日志服务，用户可以根据需求做自定义的插件开发来处理日志。</li>
<li><strong>管理进程</strong>管理或维护应用的运行状态是软件维护的基础部分，比如数据库迁移、健康检查、安全巡检等，在与应用长期运行的程序相同环境中，作为一次性程序运行。在应用架构模式中，比如Kubernetes里面的Pod资源或者dockerexec，可以随着其他的应用程序一起发布或在出现异常诊断时能通过相关的程序去管理其状态。云原生的内容非常广泛，目前没有系统的说明和完整的定义，上文介绍了云原生应用的基础组件和相关特点，可能读者对云原生应用的逻辑还存在一些困惑。为了更清楚地进行说明，我们总结了其依赖关系，如图所示。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MF3QcUFhrlymZEcezKdnNTwsmz6PmrJMrAiaRbPb4oGAzFShWia9AIRfAvf77iczDuGc9YD9diciabQFHGdjRN3VRXg/640?wx_fmt=jpeg" alt="img"></p>
<p>首先，为了抓住商业机会，业务需要快速迭代，不断试错，因此，企业需要依赖拥有持续交付的能力，这些不仅包括技术需求还包括产品的需求，如何能拥有持续交付的能力，大而全的架构因为效率低下，显然是不合适的。于是演变出微服务架构来满足需求，通过把系统划分出一个个独立的个体，每个个体服务的设计依赖需要通过12要素的原则来规范完成。<br>同样，如果系统被分成了几十个甚至几百个服务组件，则需要借助DevOps才能很好地满足业务协作和发布等流程。最后，DevOps的有效实施需要依赖一定的土壤，即敏捷的基础设施服务，现实只有云计算的模式才能满足整体要求。通过上述梳理，我们总结出面向云原生应用的3个不同层次的特点。</p>
<ul>
<li><strong><em>高可用设计（Design for Availability）\</em></strong>，依据应用业务需求，高可用分为不同级别，比如不同区域、不同机房（跨城或同城）、不同机柜、不同服务器和不同进程的高可用，云原生应用应该根据业务的可用性要求设计不同级别的架构支持。</li>
<li><strong><em>可扩展设计（Design for Scale）</em></strong>，所有应用的设计是无状态的，使得业务天生具有扩展性，在业务流量高峰和低峰时期，依赖云的特性自动弹性扩容，满足业务需求。</li>
<li><strong><em>快速失败设计（Design for Failure）</em></strong>，即包括系统间依赖的调用随时可能会失败，也包括硬件基础设施服务随时可能宕机，还有后端有状态服务的系统能力可能有瓶颈，总之在发生异常时能够快速失败，然后快速恢复，以保证业务永远在线，不能让业务半死不活地僵持着。</li>
</ul>
<p>通过上面的基本描述及云原生应用的组成或特点，与容器技术（第2章将详细介绍）相比可以得知，容器的特性天生就是按这些原则进行设计的。随着互联网业务的架构不断演进，从单体应用到分布式应用，甚至微服务架构应用中，12要素较好地为构建互联网化应用提供了统一的方法论和标准化，具有强大的生命力，每一条原则都是应用开发的珠玑。当然，在实践过程中，每一个原则也不是一成不变的，随着新的理念和技术出现，原有的因素会得到延伸和发展，会出现新的原则和应用，这套理论也适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序，因此也作为云原生架构应用的基本指导原则之一。<strong>注：**</strong>本文节选自《云原生应用架构实践》，网易云基础服务架构团队著，全程详解单体到分布式服务化架构的演进。更多精彩内容，敬请期待下期分享。**</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/11/28/Node%E7%8A%B6%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Long Kaixiang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Longkx's notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/11/28/Node%E7%8A%B6%E6%80%81/" class="post-title-link" itemprop="url">kubernetes节点（Node）状态</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-28 11:18:35" itemprop="dateCreated datePublished" datetime="2017-11-28T11:18:35+08:00">2017-11-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-20 11:20:56" itemprop="dateModified" datetime="2020-11-20T11:20:56+08:00">2020-11-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/kubernetes/" itemprop="url" rel="index"><span itemprop="name">kubernetes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>由于项目上要用节点亲和需要返回所有可用的节点。遂整理一下<strong>Node</strong>的属性，特别是<strong>status</strong>。</p>
<p><strong>Node</strong>是<strong>kubernetes</strong>集群中的一台工作中的虚拟机或者物理机。每个<strong>Node</strong>上运行着<strong>Docker</strong>,<strong>kubelet</strong>,<strong>kube-proxy</strong>。<br>详细介绍参考<a target="_blank" rel="noopener" href="https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node">The Kubernetes Node</a></p>
<h1 id="Node-Status"><a href="#Node-Status" class="headerlink" title="Node Status"></a>Node Status</h1><h2 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h2><ul>
<li><strong>HostName</strong>：主机名。可以通过<strong>kubelet</strong>的**–hostname-override**参数重写。</li>
<li><strong>ExternalIP</strong>：集群外部访问<strong>IP</strong>。</li>
<li><strong>InternalIP</strong>：集群内部访问<strong>IP</strong>。</li>
</ul>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p><strong>Condition</strong>用以描述机器的运行状态。</p>
<ul>
<li><p><strong>OutOfDisk</strong>：当节点上没有充足的空间创建<strong>Pod</strong>时值为<strong>True</strong>。</p>
</li>
<li><p><strong>Ready</strong>：当节点是健康的状态且可以创建<strong>Pod</strong>时为<strong>True</strong>；节点不健康且无法创建<strong>Pod</strong>时为<strong>False</strong>；而当<strong>node controller</strong>40s内无法检查到<strong>Node</strong>状态时，值为<strong>Unknown</strong>。</p>
</li>
<li><p><strong>MemoryPressure</strong>：当节点的内存使用存在压力，即可用内存低时值为<strong>True</strong>。</p>
</li>
<li><p><strong>DiskPressure</strong>：当节点的硬盘空间存在压力，即可用存储低时值为<strong>True</strong>。</p>
</li>
<li><p><strong>NetworkUnavailable</strong>：节点的网络配置异常时为<strong>True</strong>。</p>
</li>
</ul>
<p>当<strong>Ready</strong>为<strong>Unknown</strong>或者<strong>False</strong>状态超过<strong>kube-controller-manager</strong>的参数<strong>pod-eviction-timeout</strong>所设定的时间（默认5分钟）时，该节点上的所有<strong>Pod</strong>将会被<strong>Node Controller</strong>删除。</p>
<h2 id="Capacity"><a href="#Capacity" class="headerlink" title="Capacity"></a>Capacity</h2><p><strong>Capacity</strong>用来描述节点的<strong>CPU</strong>，<strong>memory</strong>，以及可以创建<strong>Pod</strong>的最大数量。</p>
<p>##Info</p>
<p>通过<strong>Kubelet</strong>获取的节点一般信息。</p>
<h1 id="Node管理"><a href="#Node管理" class="headerlink" title="Node管理"></a>Node管理</h1><p>标记一个节点使其不可被调度可以使新<strong>Pod</strong>不会被调度到这个节点上，同时不会影响已经在节点上运行的<strong>Pod</strong>。这是节点重新启动之前必要的的准备步骤。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl cordon $NODENAME</span><br></pre></td></tr></table></figure>

<p>通过下面的占位<strong>Pod</strong>可以实现预留一部分节点资源用于处理非<strong>Pod</strong>进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: resource-reserver</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: sleep-forever</span><br><span class="line">    image: gcr.io&#x2F;google_containers&#x2F;pause:0.8.0</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        cpu: 100m</span><br><span class="line">        memory: 100Mi</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/11/17/kubernetes%E8%B5%84%E6%BA%90%E6%8D%A2%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Long Kaixiang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Longkx's notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/11/17/kubernetes%E8%B5%84%E6%BA%90%E6%8D%A2%E7%AE%97/" class="post-title-link" itemprop="url">kubernetes资源换算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-17 15:18:35" itemprop="dateCreated datePublished" datetime="2017-11-17T15:18:35+08:00">2017-11-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-20 11:20:56" itemprop="dateModified" datetime="2020-11-20T11:20:56+08:00">2020-11-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/kubernetes/" itemprop="url" rel="index"><span itemprop="name">kubernetes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="CPU单位的计算"><a href="#CPU单位的计算" class="headerlink" title="CPU单位的计算"></a>CPU单位的计算</h2><p>cpu单位计算比较简单，因为cpu只有单位m或者没有单位。换算为：1CPU=1000m。</p>
<h2 id="Memory的计算"><a href="#Memory的计算" class="headerlink" title="Memory的计算"></a>Memory的计算</h2><p>Memory的换算相对要复杂一些。Memory的单位分为两类：</p>
<ol>
<li>两个单位间相差10的三次方的单位：E，P，T，G，M，K，k，m，u，n。</li>
<li>两个单位间相差2的十次方的单位：Ei, Pi, Ti, Gi, Mi, Ki。</li>
</ol>
<h2 id="换算函数"><a href="#换算函数" class="headerlink" title="换算函数"></a>换算函数</h2><p>下面提供一个简单的内存换算函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * convertMemory:转换内存值字符串为无单位数值. &lt;br&#x2F;&gt;</span><br><span class="line"> *</span><br><span class="line"> * @param memory</span><br><span class="line"> * @return double</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static double parseMemory(String memory) &#123;</span><br><span class="line">	if (StringUtils.isEmpty(memory)) &#123;</span><br><span class="line">		return 0d;</span><br><span class="line">	&#125;</span><br><span class="line">	memory &#x3D; memory.replaceAll(&quot;i&quot;, &quot;&quot;);</span><br><span class="line">	double ret;</span><br><span class="line">	if (memory.endsWith(&quot;n&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;n&quot;, &quot;&quot;)) * Math.pow(10, -9);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;u&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;u&quot;, &quot;&quot;)) * Math.pow(10, -6);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;m&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;m&quot;, &quot;&quot;)) * Math.pow(10, -3);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;k&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;k&quot;, &quot;&quot;)) * Math.pow(10, 3);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;K&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;K&quot;, &quot;&quot;)) * Math.pow(10, 3);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;M&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;M&quot;, &quot;&quot;)) * Math.pow(10, 6);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;G&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;G&quot;, &quot;&quot;)) * Math.pow(10, 9);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;T&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;T&quot;, &quot;&quot;)) * Math.pow(10, 12);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;P&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;P&quot;, &quot;&quot;)) * Math.pow(10, 15);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;E&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;E&quot;, &quot;&quot;)) * Math.pow(10, 18);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;Ki&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;Ki&quot;, &quot;&quot;)) * Math.pow(2, 10);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;Mi&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;Mi&quot;, &quot;&quot;)) * Math.pow(2, 20);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;Gi&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;Gi&quot;, &quot;&quot;)) * Math.pow(2, 30);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;Ti&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;Ti&quot;, &quot;&quot;)) * Math.pow(2, 40);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;Pi&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;Pi&quot;, &quot;&quot;)) * Math.pow(2, 50);</span><br><span class="line">	&#125; else if (memory.endsWith(&quot;Ei&quot;)) &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory.replace(&quot;Ei&quot;, &quot;&quot;)) * Math.pow(2, 60);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ret &#x3D; Double.parseDouble(memory);</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/11/13/Pods%E4%BA%B2%E5%92%8C%E4%B8%8E%E5%8F%8D%E4%BA%B2%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Long Kaixiang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Longkx's notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/11/13/Pods%E4%BA%B2%E5%92%8C%E4%B8%8E%E5%8F%8D%E4%BA%B2%E5%92%8C/" class="post-title-link" itemprop="url">Pod亲和与反亲和</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-13 17:16:24" itemprop="dateCreated datePublished" datetime="2017-11-13T17:16:24+08:00">2017-11-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-20 11:20:56" itemprop="dateModified" datetime="2020-11-20T11:20:56+08:00">2020-11-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/kubernetes/" itemprop="url" rel="index"><span itemprop="name">kubernetes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Nodeselector"><a href="#Nodeselector" class="headerlink" title="Nodeselector"></a>Nodeselector</h2><p><strong>Nodeselector</strong>是最简明的节点绑定方式。<br>通过下面的命令可以给指定的<strong>Node</strong>添加<strong>label</strong>（旧版本可能没有<strong>label</strong>命令，可通过其他方式添加或修改）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label Node &lt;node-name&gt; &lt;label-key&gt;&#x3D;&lt;label-value&gt;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label Node node1 disktype&#x3D;ssd</span><br></pre></td></tr></table></figure>
<p><strong>Pod</strong>的<strong>yaml</strong>如下添加了<strong>Nodeselector</strong>域： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    env: test</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">  Nodeselector:</span><br><span class="line">    disktype: ssd</span><br></pre></td></tr></table></figure>
<p>这样执行创建命令（kubectl create -f pod.yaml）后，<strong>Pod</strong>会调度到有指定键值对disktype: ssd的节点上运行。</p>
<h2 id="默认label"><a href="#默认label" class="headerlink" title="默认label"></a>默认label</h2><p>在kubernetes v1.4版本之后，<strong>Node</strong>会默认添加以下几个<strong>label</strong>：</p>
<ul>
<li>kubernetes.io/hostname</li>
<li>failure-domain.beta.kubernetes.io/zone</li>
<li>failure-domain.beta.kubernetes.io/region</li>
<li>beta.kubernetes.io/instance-type</li>
<li>beta.kubernetes.io/os</li>
<li>beta.kubernetes.io/arch</li>
</ul>
<p>可以通过下面命令查看<strong>Node</strong>的<strong>labels</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get Node --show-labels</span><br></pre></td></tr></table></figure>

<h2 id="亲和与反亲和-Affinity-and-anti-affinity"><a href="#亲和与反亲和-Affinity-and-anti-affinity" class="headerlink" title="亲和与反亲和(Affinity and anti-affinity)"></a>亲和与反亲和(Affinity and anti-affinity)</h2><p><strong>Pod</strong>亲和与反亲和位于<strong>Podpec</strong>中的<strong>affinity</strong>域下。<br><strong>affinity/anti-affinity</strong>极大地扩展了<strong>Pod</strong>的绑定方式，提供了更多样化的调度策略。主要有以下优点：</p>
<ol>
<li>语法更加丰富，支持更多的逻辑。</li>
<li>可以进行<strong>软指定</strong>，当<strong>Node</strong>都不满足条件时，<strong>Pod</strong>依然会被运行。</li>
<li>可以根据节点上<strong>Pod</strong>的<strong>label</strong>进行调度，从而实现<strong>Pod</strong>的亲和与反亲和。</li>
</ol>
<p>亲和与反亲和包含<strong>节点亲和（node affinity）</strong>和<strong>Pod亲和与反亲和（inter-pod affinity/anti-affinity）</strong>两个类型。前者与<strong>Nodeselector</strong>类似，是针对<strong>Node</strong>进行绑定，但是具有亲和的前两个优点。而后者则是针对<strong>Pod</strong>的调度，兼具三个优点。</p>
<ul>
<li>Nodeselector现版本仍然有效，但最终会被亲和所取代。</li>
</ul>
<h3 id="节点亲和（Node-affinity）"><a href="#节点亲和（Node-affinity）" class="headerlink" title="节点亲和（Node affinity）"></a>节点亲和（Node affinity）</h3><p>节点亲和出现在kubernetes v1.2α版本。其包含两种类型：<strong>requiredDuringSchedulingIgnoredDuringExecution</strong>和<strong>preferredDuringSchedulingIgnoredDuringExecution</strong>。前者指定的规则必须硬性满足（硬亲和），而后者的规则是作为偏好，调度器会尝试但不保证满足（软亲和）。名字中的”DuringSchedulingIgnoredDuringExecution”是指<strong>Pod</strong>运行中如果<strong>Node</strong>不再满足亲和规则，<strong>Pod</strong>仍然会在该<strong>Node</strong>上运行。未来版本<strong>kubernetes</strong>将计划提供<strong>requiredDuringSchedulingRequiredDuringExecution</strong>参数，用以驱逐<strong>Node</strong>上不再满足亲和规则的<strong>Pod</strong>。<br>看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: with-node-affinity</span><br><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        NodeselectorTerms:</span><br><span class="line">        - matchExpressions:</span><br><span class="line">          - key: kubernetes.io&#x2F;e2e-az-name</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - e2e-az1</span><br><span class="line">            - e2e-az2</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 1</span><br><span class="line">        preference:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: another-node-label-key</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - another-node-label-value</span><br><span class="line">  containers:</span><br><span class="line">  - name: with-node-affinity</span><br><span class="line">    image: gcr.io&#x2F;google_containers&#x2F;pause:2.0</span><br></pre></td></tr></table></figure>
<p>该<strong>Pod</strong>会在满足<strong>kubernetes.io/e2e-az-name</strong>值为<strong>e2e-az1</strong>或<strong>e2e-az2</strong>的<strong>Node</strong>中优先调度到<strong>another-node-label-key</strong>值为<strong>another-node-label-value</strong>的<strong>Node</strong>上。<br>在例子中看到<strong>operator</strong>值为<strong>In</strong>，同时它还支持<strong>NotIn</strong>，<strong>Exists</strong>，<strong>DoesNotExist</strong>，<strong>Gt</strong>，<strong>Lt</strong>。我们可以通过<strong>NotIn</strong>，<strong>DoesNotExist</strong>来实现<strong>Node</strong>的反亲和。使用<strong>node affinity</strong>需要注意的几点如下：</p>
<ul>
<li><strong>Nodeselector</strong>和<strong>nodeAffinity</strong>同时设定时，两个规则同时生效。</li>
<li>当<strong>nodeAffinity</strong>下有多个<strong>NodeselectorTerms</strong>时，他们之间是<strong>或</strong>的关系，只满足其中一个<strong>NodeselectorTerms</strong>的<strong>Node</strong>都符合亲和规则。</li>
<li>当<strong>NodeselectorTerms</strong>下有多个<strong>matchExpressions</strong>时，他们之间是<strong>和</strong>的关系，满足全部<strong>matchExpressions</strong>的<strong>Node</strong>才符合亲和规则。</li>
<li>当<strong>Node</strong>的<strong>label</strong>改变而不满足规则时，<strong>Pod</strong>不会被驱逐，即亲和规则只在<strong>Pod</strong>启动时做一次判断。</li>
</ul>
<p>更多信息请参考<a target="_blank" rel="noopener" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/nodeaffinity.md">Node affinity and Nodeselector</a></p>
<h3 id="Pod亲和与反亲和（Inter-pod-affinity-and-anti-affinity）"><a href="#Pod亲和与反亲和（Inter-pod-affinity-and-anti-affinity）" class="headerlink" title="Pod亲和与反亲和（Inter-pod affinity and anti-affinity）"></a>Pod亲和与反亲和（Inter-pod affinity and anti-affinity）</h3><p>Pod亲和与反亲和出现在kubernetes v1.4版本。<br>与<strong>Node</strong>亲和相同，<strong>Pod</strong>亲和与反亲和也包含<strong>requiredDuringSchedulingIgnoredDuringExecution</strong>和<strong>preferredDuringSchedulingIgnoredDuringExecution</strong>两种类型，分别对应硬亲和和软亲和。</p>
<ul>
<li>Pod亲和与反亲和需要大量的处理，这样会显著减慢大集群中的调度。我们不建议在大于几百个节点的集群中使用它们。</li>
<li>建议当两个<strong>Pod</strong>相互之间访问较多时可使用硬亲和使他们能在同一<strong>Node</strong>上运行。而<strong>Pod</strong>反亲和时因为有可能<strong>Pod</strong>数量会大于节点<strong>Node</strong>数，建议使用软亲和。</li>
</ul>
<p>看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: with-pod-affinity</span><br><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    podAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: security</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - S1</span><br><span class="line">        topologyKey: failure-domain.beta.kubernetes.io&#x2F;zone</span><br><span class="line">    podAntiAffinity:</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 100</span><br><span class="line">        podAffinityTerm:</span><br><span class="line">          labelSelector:</span><br><span class="line">            matchExpressions:</span><br><span class="line">            - key: security</span><br><span class="line">              operator: In</span><br><span class="line">              values:</span><br><span class="line">              - S2</span><br><span class="line">          topologyKey: kubernetes.io&#x2F;hostname</span><br><span class="line">  containers:</span><br><span class="line">  - name: with-pod-affinity</span><br><span class="line">    image: gcr.io&#x2F;google_containers&#x2F;pause:2.0</span><br></pre></td></tr></table></figure>

<p>这个<strong>Pod</strong>的调度规则如下：<br><strong>Pod</strong>亲和为硬亲和，要求部署到的<strong>Node</strong>必须包含带有<strong>failure-domain.beta.kubernetes.io/zone</strong>的<strong>key</strong>，且该<strong>Node</strong>上运行着包含<strong>security: S1</strong>的<strong>Pod</strong><br><strong>Pod</strong>反亲和为软亲和，要求<strong>Pod</strong>优先部署到不满足条件（<strong>Node</strong>包含带有<strong>kubernetes.io/hostname</strong>的<strong>key</strong>，且该<strong>Node</strong>上运行着包含<strong>security: S2</strong>的<strong>Pod</strong>）的<strong>Node</strong>上</p>
<p>虽然<strong>topologyKey</strong>基本可以是任何合法值，但在考虑到性能和安全方面，有如下的限制：</p>
<ul>
<li>反亲和为硬亲和（<strong>RequiredDuringScheduling</strong>）时，<strong>topologyKey</strong>不能为空。</li>
<li><strong><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/admin/admission-controllers">Admission Controllers</a>**中设置</strong><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/admin/admission-controllers/#limitpodhardantiaffinity">LimitPodHardAntiAffinity</a><strong>启用时，反亲和为硬亲和（</strong>RequiredDuringScheduling<strong>）的</strong>topologyKey<strong>只能为</strong>kubernetes.io/hostname**。</li>
<li>在反亲和为软亲和（<strong>PreferredDuringScheduling</strong>）时，<strong>topologyKey</strong>为空时则指代所有的拓扑结构。但现在“所有的拓扑结构”被限制为以下几个<strong>topologyKey</strong>：<strong>kubernetes.io/hostname</strong>, <strong>failure-domain.beta.kubernetes.io/zone</strong>和<strong>failure-domain.beta.kubernetes.io/region</strong>。</li>
<li>除了以上几种情况，<strong>topologyKey</strong>可以是任意合法值。</li>
</ul>
<h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/">https://kubernetes.io/docs/concepts/configuration/assign-pod-node/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/nodeaffinity.md">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/nodeaffinity.md</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/podaffinity.md">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/podaffinity.md</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/admin/admission-controllers/#limitpodhardantiaffinity">https://kubernetes.io/docs/admin/admission-controllers/#limitpodhardantiaffinity</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>






<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Long Kaixiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
